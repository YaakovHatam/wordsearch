{"version":3,"sources":["helpers/categories.ts","store/reducers/categories.reducer.ts","components/choose-category.tsx","components/word-table.tsx","helpers/word-packer.ts","components/word-search.tsx","App.js","reportWebVitals.js","store/store.ts","index.js"],"names":["a","fetch","process","json","categoriesSlice","createSlice","name","initialState","values","reducers","setCategories","state","action","payload","actions","selectCategories","categories","ChooseCategory","useNavigate","dispatch","useDispatch","useSelector","useEffect","WordSearchCategories","then","res","className","Object","entries","map","wsc","to","heb","desc","role","jsonFile","WordTable","props","useState","wordSearchTable","setWordSearchTable","availableSlots","setAvailableSlots","showAnswers","setShowAnswers","length","Button","onClick","e","variant","r","ri","c","ci","classNames","WordPacker","width","height","directions","letterGrid","letterGridWithoutFill","skippedWords","words","this","initializeLetterGrid","rowIncrement","columnIncrement","word","normalizedWord","split","join","String","fromCharCode","wordOverlapsCompletely","push","tryToAddWord","rowIndex","columnIndex","randLetter","row","slice","Array","fill","letters","from","x","i","splice","indexOf","randRange","maxValue","Math","floor","random","randomIndex","temp","rowStart","columnStart","direction","letter","shuffle","maxAttempts","attempt","tryToAddLettersInDirection","toUpperCase","normaliezdPackedWords","packedWord","normalizedPackedWord","includes","packer","sortedWords","sort","b","addWord","arr","finalize","WordSearch","params","useParams","selectedWords","setSelectedWords","category","fetchWordsAndMakeTables","jsonPath","jRes","wordPacker","createWordPacker","getLetterGrid","getLetterGridClean","getWords","makeTables","w","wi","tabIndex","title","App","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","configureStore","reducer","categoriesReducer","ReactDOM","render","StrictMode","store","ThemeProvider","dir","document","getElementById"],"mappings":"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","file":"static/js/main.7b1484ca.chunk.js","sourcesContent":["import { IWordSearchCategories } from \"../models/categories.model\";\n\nexport async function WordSearchCategories(): Promise<IWordSearchCategories> {\n   return (await fetch(`${process.env.PUBLIC_URL}/words/1categories.json`))\n      .json();\n}","import { createSlice } from '@reduxjs/toolkit'\nimport { IState } from '../store';\n\nexport const categoriesSlice = createSlice({\n   name: 'categories',\n   initialState: {\n      values: []\n   },\n   reducers: {\n      setCategories: (state, action) => {\n         state.values = action.payload;\n      }\n   },\n})\n\nexport const { setCategories } = categoriesSlice.actions\n\nexport const selectCategories = (state: IState) => state.categories.values;\n\nexport default categoriesSlice.reducer","import { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { Link, useNavigate } from \"react-router-dom\";\nimport { WordSearchCategories } from \"../helpers/categories\";\nimport { selectCategories, setCategories } from \"../store/reducers/categories.reducer\";\n\nexport function ChooseCategory() {\n   const navigate = useNavigate();\n   const dispatch = useDispatch()\n\n\n   const categories = useSelector(selectCategories)\n\n   useEffect(() => {\n      WordSearchCategories().then(res => dispatch(setCategories(res)))\n   }, [])\n\n   return (\n      <div className=\"container mt-5\">\n         {/*<label>בחירת גודל תפזורת:\n            <select className=\"form-select form-select-lg\" size={8} aria-label=\"size 3 select example\">\n               <option value=\"1\">23 שורות ו34 עמודות</option>\n               <option value=\"2\">Two</option>\n               <option value=\"3\">Three</option>\n            </select>\n         </label>*/}\n         <div className=\"row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 g-4 py-5\">\n            {Object.entries(categories).map(wsc =>\n               <Link key={wsc[1].jsonFile} to={`/generate/${wsc[0]}`}>My Profile\n                  <div className=\"col d-flex align-items-start\">\n                     <div>\n                        <h2 className=\"fw-bold mb-0\">{wsc[1].heb}</h2>\n                        <p>{wsc[1].desc}</p>\n                        <span role='button' className=\"btn btn-lg btn-light\">לחולל תשבץ</span>\n                     </div>\n                  </div>\n               </Link>\n            )}\n         </div>\n      </div>\n   );\n}\n","import { useEffect, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { Button } from \"react-bootstrap\";\n\ninterface WordTableProps {\n   wordSearchTable: string[][];\n   availableSlots: string[][];\n}\nexport function WordTable(props: WordTableProps) {\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\n   const [showAnswers, setShowAnswers] = useState<boolean>(false);\n\n   useEffect(() => {\n      setWordSearchTable(props.wordSearchTable);\n   }, [props.wordSearchTable]);\n\n   useEffect(() => {\n      setAvailableSlots(props.availableSlots);\n   }, [props.availableSlots]);\n\n   return (\n      (wordSearchTable.length > 0 && availableSlots.length > 0) ?\n         <>\n            <div className=\"text-end my-3 d-print-none\">\n               <Button onClick={e => setShowAnswers(!showAnswers)} variant={showAnswers ? \"primary\" : \"outline-secondary\"}>הראה תשובות...</Button>\n            </div>\n            <table className='table table-bordered border-dark text-center fs-5'>\n               <tbody>\n                  {wordSearchTable.map((r, ri) =>\n                     <tr className=\"table-light\" key={ri}>{r.map((c, ci) =>\n                        <td className={classNames({\n                           \"table-primary\": availableSlots[ri][ci] === c && showAnswers\n                        })}\n                           key={ci}>{c}</td>\n                     )}\n                     </tr>\n                  )}\n               </tbody>\n            </table>\n         </> : <></>\n   );\n}\n","\nexport type LetterGrid = string[][];\n\ninterface Direction {\n   rowIncrement: number;\n   columnIncrement: number;\n}\n\nvar EMPTY_LETTER = \"\";\n\n// I pack words into a two-dimension letter-grid, randomizing the location and the\n// orientation of the characters that compose the packed words.\nexport class WordPacker {\n\n   private directions: Direction[];\n   private letterGrid: LetterGrid;\n   private letterGridWithoutFill: LetterGrid;\n   private height: number;\n   private skippedWords: string[];\n   private width: number;\n   private words: string[];\n\n   // I initialize the word packer with the given grid dimensions.\n   constructor(width: number, height: number) {\n\n      this.width = width;\n      this.height = height;\n      this.words = [];\n      this.skippedWords = [];\n\n      this.letterGrid = this.initializeLetterGrid();\n      this.letterGridWithoutFill = this.initializeLetterGrid();\n\n      // As we try to add words to the underlying letter-grid, we're going to try and\n      // apply them in different directions. The following collection represents the\n      // ROW and COLUMN increments for each direction that we are going to try.\n      this.directions = [\n         { // North.\n            rowIncrement: -1,\n            columnIncrement: 0\n         },\n         { // North-East.\n            rowIncrement: -1,\n            columnIncrement: 1\n         },\n         { // East.\n            rowIncrement: 0,\n            columnIncrement: 1\n         },\n         { // South-East.\n            rowIncrement: 1,\n            columnIncrement: 1\n         },\n         { // South.\n            rowIncrement: 1,\n            columnIncrement: 0\n         },\n         { // South-West.\n            rowIncrement: 1,\n            columnIncrement: -1\n         },\n         { // West.\n            rowIncrement: 0,\n            columnIncrement: -1\n         },\n         { // North-West.\n            rowIncrement: -1,\n            columnIncrement: -1\n         }\n      ];\n\n   }\n\n   // ---\n   // STATIC METHODS.\n   // ---\n\n   // I create a WordPacker for the given words using a grid with the given dimensions.\n   // Returns the populated WordPacker instance.\n   static createWordPacker(\n      words: string[],\n      width: number,\n      height: number\n   ): WordPacker {\n\n      const packer = new WordPacker(width, height);\n\n      // Sort the words with the longest values first. This will increase the chances\n      // of us being able to add more words to the grid (since smaller words can act\n      // more easily as \"filler words\", packing in the empty spaces).\n      const sortedWords = words.slice().sort((a, b) => (b.length - a.length));\n\n      for (var word of sortedWords) {\n         packer.addWord(word);\n      }\n      packer.letterGridWithoutFill = packer.letterGrid.map(arr => arr.slice());\n      // Fill in the rest of the empty spaces with random words.\n      packer.finalize();\n\n      return (packer);\n\n   }\n\n   // ---\n   // PUBLIC METHODS.\n   // ---\n\n   // I add the given word to the packer. Returns a boolean indicating whether or not\n   // the given word could be packed into the two-dimensional letter-grid.\n   public addWord(word: string): boolean {\n\n      var normalizedWord = word.split(' ').join('');\n      normalizedWord = normalizedWord.split('\\'').join('');\n      normalizedWord = normalizedWord.split('-').join('');\n      normalizedWord = normalizedWord.split(String.fromCharCode(1498)).join(String.fromCharCode(1499));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1501)).join(String.fromCharCode(1502));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1503)).join(String.fromCharCode(1504));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1507)).join(String.fromCharCode(1508));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1509)).join(String.fromCharCode(1510));\n\n\n      // If the given word can be wholly subsumed by one of the words that's already\n      // been packed into the letter-grid, it should be skipped since including it\n      // would lead to a confusing user experience (UX).\n      if (this.wordOverlapsCompletely(normalizedWord)) {\n         this.skippedWords.push(normalizedWord);\n         return (false);\n\n      }\n\n      if (this.tryToAddWord(normalizedWord)) {\n\n         this.words.push(word);\n         return (true);\n\n      } else {\n         this.skippedWords.push(word);\n         return (false);\n\n      }\n\n   }\n\n\n   // I finalize the two-dimensional letter-grid, filling-in any remaining spaces with\n   // random letters (A-Z).\n   public finalize(): void {\n      for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\n         for (let columnIndex = 0; columnIndex < this.width; columnIndex++) {\n            // If this grid-location is filled-in, move onto the next location.\n            if (this.letterGrid[rowIndex][columnIndex]) {\n\n               continue;\n\n            }\n\n            this.letterGrid[rowIndex][columnIndex] = this.randLetter();\n\n         }\n      }\n\n   }\n\n\n   // I return the two-dimensional letter-grid.\n   public getLetterGrid(): LetterGrid {\n\n      // In order to prevent our internal data-model from leaking out in a mutable\n      // fashion (ie, such that our internal structure could be mutated by an external\n      // context), we need to return a DEEP COPY of the letter grid.\n      return (this.letterGrid.map(row => row.slice()));\n\n   }\n\n   public getLetterGridClean(): LetterGrid {\n      return this.letterGridWithoutFill.map(row => row.slice());\n   }\n\n   // I return the words that could not be packed into the letter-grid.\n   public getSkippedWords(): string[] {\n      return (this.skippedWords.slice());\n   }\n\n   // I return the words that were packed into the letter-grid.\n   public getWords(): string[] {\n      return (this.words.slice());\n   }\n\n   // ---\n   // PRIVATE METHODS.\n   // ---\n\n   // I create an empty letter-grid for the current letter-packer.\n   private initializeLetterGrid(): LetterGrid {\n      const row: string[] = new Array(this.width).fill(EMPTY_LETTER);\n\n      // The empty grid will use a row-first orientation (since this is easier to\n      // render in the HTML markup).\n      return new Array(this.height).fill(EMPTY_LETTER).map(() => row.slice());\n\n   }\n\n\n   // I return a random letter between A-Z.\n   private randLetter(): string {\n\n      const letters = Array.from({ length: 27 }, (x, i) => i + 1488);\n      letters.splice(letters.indexOf(1498), 1);\n      letters.splice(letters.indexOf(1501), 1);\n      letters.splice(letters.indexOf(1503), 1);\n      letters.splice(letters.indexOf(1507), 1);\n      letters.splice(letters.indexOf(1509), 1);\n\n      return String.fromCharCode(letters[this.randRange(letters.length)]);\n   }\n\n\n   // I return a random value between 0 (inclusive) and the given value (exclusive).\n   private randRange(maxValue: number): number {\n      return (Math.floor(Math.random() * maxValue));\n\n   }\n\n\n   // I shuffle the given array of values in place.\n   private shuffle<T>(values: T[]): T[] {\n\n      for (var i = 0, length = values.length; i < length; i++) {\n         var randomIndex = this.randRange(length);\n\n         // Swap the values in the current index and the random index.\n         var temp = values[i];\n         values[i] = values[randomIndex];\n         values[randomIndex] = temp;\n\n      }\n\n      return (values);\n\n   }\n\n\n   // I try to add the given letters in the given direction at the given location on the\n   // letter-grid. Returns boolean indicating whether or not the letter-grid has been\n   // updated with the letters.\n   private tryToAddLettersInDirection(\n      letters: string[],\n      rowStart: number,\n      columnStart: number,\n      direction: Direction\n   ): boolean {\n\n      var rowIndex = rowStart;\n      var columnIndex = columnStart;\n\n      // Before we mutate the letter-grid, let's see if the collection of letters will\n      // fit on the letter-grid using the given direction.\n      for (let letter of letters) {\n\n         // If the current location has gone off the grid, we've run out of room for\n         // the letters in the given direction.\n         if (\n            (rowIndex < 0) ||\n            (rowIndex >= this.height) ||\n            (columnIndex < 0) ||\n            (columnIndex >= this.width)\n         ) {\n\n            return (false);\n\n         }\n\n         // If the current location is already populated with a non-matching letter,\n         // we've overlapped with an incompatible word.\n         if (\n            (this.letterGrid[rowIndex][columnIndex] !== EMPTY_LETTER) &&\n            (this.letterGrid[rowIndex][columnIndex] !== letter)\n         ) {\n\n            return (false);\n\n         }\n\n         rowIndex += direction.rowIncrement;\n         columnIndex += direction.columnIncrement;\n\n      }\n\n      // ASSERT: At this point, if we've made it this far, it means that all of the\n      // letters will fit into the letter-grid using the given direction. At this\n      // point, we can move ahead with applying the letters, MUTATING the letter-grid.\n      // Move back to the starting location and add each letter in turn.\n      rowIndex = rowStart;\n      columnIndex = columnStart;\n\n      for (let letter of letters) {\n\n         this.letterGrid[rowIndex][columnIndex] = letter;\n\n         rowIndex += direction.rowIncrement;\n         columnIndex += direction.columnIncrement;\n\n      }\n\n      return (true);\n\n   }\n\n\n   // I try to add the given word to letter-grid. Returns a boolean indicating whether\n   // or not the letter-grid has been updated with the given word.\n   private tryToAddWord(word: string): boolean {\n\n      var letters = word.split(\"\");\n\n      // To reduce the chances that every word is added in the same direction, we're\n      // going to randomize the order of the directions that we're going try for this\n      // word at the various locations on the letter-grid.\n      this.shuffle(this.directions);\n\n      // Randomly select the starting location on the letter-grid. From there, we will\n      // begin a linear scan of the grid, looking for a fitting location for the\n      // letters in the word.\n      var rowIndex = this.randRange(this.height);\n      var columnIndex = this.randRange(this.width);\n\n      // Performing a liner scan on a two-dimensional grid is a little tricky as we\n      // have to wrap the scan across rows and columns. We know that the MAX NUMBER of\n      // locations is equal to the TOTAL AREA of the grid.\n      var maxAttempts = (this.width * this.height);\n\n      for (var attempt = 0; attempt < maxAttempts; attempt++) {\n\n         // At each grid-location, we're going to try fitting the word in every\n         // direction, taking the first one that matches.\n         for (var direction of this.directions) {\n\n            if (this.tryToAddLettersInDirection(letters, rowIndex, columnIndex, direction)) {\n\n               return (true);\n\n            }\n\n         }\n\n         // If the current grid location didn't have room for the letters, we have to\n         // move onto the next \"linear\" location, performing a column-first scan.\n         // --\n         // CAUTION: Using PRE-INCREMENT operations here in order to increment the\n         // indices BEFORE consuming them in the equality-comparison.\n         if (++columnIndex === this.width) {\n\n            columnIndex = 0;\n\n            if (++rowIndex === this.height) {\n\n               rowIndex = 0;\n\n            }\n\n         }\n\n      }\n\n      // If we made it this far, the word could not fit into any of the scanned\n      // locations on the letter-grid.\n      return (false);\n\n   }\n\n\n   // I determine if the given word can be subsumed by (or can subsume) one of the words\n   // that's already been packed into the letter-grid (ex, \"happy\" can be wholly subsumed\n   // by \"unhappy\"). We can't allow for fully-overlapping words as it would be confusing\n   // for the consumer of the letter-grid.\n   private wordOverlapsCompletely(word: string): boolean {\n\n      // Get Upper-Case versions of our operands so that we don't have to worry about\n      // differences in case.\n      var normalizedWord = word.toUpperCase();\n      var normaliezdPackedWords = this.words.map(\n         (packedWord) => {\n\n            return (packedWord.toUpperCase());\n\n         }\n      );\n\n      for (var normalizedPackedWord of normaliezdPackedWords) {\n\n         if (\n            normalizedPackedWord.includes(normalizedWord) ||\n            normalizedWord.includes(normalizedPackedWord)\n         ) {\n\n            return (true);\n\n         }\n\n      }\n\n      return (false);\n\n   }\n\n}","import { useEffect, useState } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useParams } from \"react-router-dom\";\nimport { WordTable } from \"./word-table\";\nimport { WordPacker } from \"../helpers/word-packer\";\nimport { useSelector } from \"react-redux\";\nimport { selectCategories } from \"../store/reducers/categories.reducer\";\n\nconst randomWords = (jsonPath: string) =>\n   fetch(jsonPath).then(res => res.json().then((jRes: string[]) =>\n      jRes.sort(() => .5 - Math.random()).slice(0, 79)\n   ));\n\n\nexport function WordSearch() {\n   const ROWS = 18;\n   const COLS = 24;\n\n   const params = useParams();\n   const categories = useSelector(selectCategories);\n\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\n\n   const [selectedWords, setSelectedWords] = useState<string[]>([]);\n   const category = categories[params.category as string];\n\n   const makeTables = (words: string[]) => {\n      const wordPacker = WordPacker.createWordPacker(words, COLS, ROWS);\n\n      setWordSearchTable(wordPacker.getLetterGrid());\n      setAvailableSlots(wordPacker.getLetterGridClean());\n      setSelectedWords(wordPacker.getWords());\n   }\n   const fetchWordsAndMakeTables = () => randomWords(`${process.env.PUBLIC_URL}/words/${category.jsonFile}`).then(words => makeTables(words));\n\n   useEffect(() => {\n      fetchWordsAndMakeTables();\n   }, []);\n\n   return (\n      <>\n         <div className=\"container\">\n            <h2 className='mb-4 text-center'>תפזורת של {category.heb}</h2>\n            <div className='text-end'>\n               <Button variant=\"outline-success text-start d-print-none\" onClick={e => fetchWordsAndMakeTables()}>\n                  יצירת תשבץ חדש\n               </Button>\n            </div>\n         </div>\n         <div className=\"container\">\n            {wordSearchTable.length > 0 ?\n               <WordTable wordSearchTable={wordSearchTable} availableSlots={availableSlots} />\n               : <></>}\n         </div>\n         <div className=\"container\">\n            <section className='row fs-5 d-flex'>\n               {selectedWords.map((w, wi) => <div key={wi} tabIndex={0} className=\"col-2 flex-grow-1 \" title={w}>{w}</div>)}\n            </section>\n         </div>\n      </>\n   );\n}\n","import './App.css';\nimport { ChooseCategory } from \"./components/choose-category\";\nimport { WordSearch } from \"./components/word-search\";\n\nimport { BrowserRouter, MemoryRouter, Routes, Route } from \"react-router-dom\";\n\nfunction App() {\n   return (\n      <MemoryRouter>\n         <Routes>\n            <Route path=\"/\" element={<ChooseCategory />} />\n            <Route path=\"/generate/:category\" element={<WordSearch />} />\n         </Routes>\n      </MemoryRouter>\n   );\n}\n\nexport default App;\n\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { configureStore } from '@reduxjs/toolkit'\nimport { IWordSearchCategories } from '../models/categories.model'\nimport categoriesReducer from './reducers/categories.reducer'\n\nexport interface IState {\n   categories: {\n      values: IWordSearchCategories;\n   }\n}\n\nexport default configureStore({\n   reducer: {\n      categories: categoriesReducer\n   },\n})","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.rtl.min.css';\nimport { ThemeProvider } from \"react-bootstrap\";\nimport { Provider } from 'react-redux';\nimport store from './store/store';\n\nReactDOM.render(\n   <React.StrictMode>\n      <Provider store={store}>\n\n         <ThemeProvider dir=\"rtl\">\n            <App />\n         </ThemeProvider>\n      </Provider>\n   </React.StrictMode>,\n   document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}