{"version":3,"sources":["helpers/categories.ts","store/reducers/categories.reducer.ts","components/choose-category.tsx","components/word-table.tsx","helpers/word-packer.ts","components/word-search.tsx","App.js","reportWebVitals.js","store/store.ts","index.js"],"names":["a","fetch","process","json","categoriesSlice","createSlice","name","initialState","values","reducers","setCategories","state","action","payload","actions","selectCategories","categories","ChooseCategory","useNavigate","dispatch","useDispatch","useSelector","useEffect","WordSearchCategories","then","res","className","Object","entries","map","wsc","to","heb","desc","role","jsonFile","WordTable","props","useState","wordSearchTable","setWordSearchTable","availableSlots","setAvailableSlots","showAnswers","setShowAnswers","length","Button","onClick","e","variant","r","ri","c","ci","classNames","WordPacker","width","height","directions","letterGrid","letterGridWithoutFill","skippedWords","words","this","initializeLetterGrid","rowIncrement","columnIncrement","word","normalizedWord","split","join","String","fromCharCode","wordOverlapsCompletely","push","tryToAddWord","rowIndex","columnIndex","randLetter","row","slice","Array","fill","letters","from","x","i","splice","indexOf","randRange","maxValue","Math","floor","random","randomIndex","temp","rowStart","columnStart","direction","letter","shuffle","maxAttempts","attempt","tryToAddLettersInDirection","toUpperCase","normaliezdPackedWords","packedWord","normalizedPackedWord","includes","packer","sortedWords","sort","b","addWord","arr","finalize","WordSearch","params","useParams","selectedWords","setSelectedWords","category","fetchWordsAndMakeTables","jsonPath","jRes","wordPacker","createWordPacker","getLetterGrid","getLetterGridClean","getWords","makeTables","w","wi","tabIndex","title","App","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","configureStore","reducer","categoriesReducer","ReactDOM","render","StrictMode","store","ThemeProvider","dir","document","getElementById"],"mappings":"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","file":"static/js/main.264a1ea3.chunk.js","sourcesContent":["import { IWordSearchCategories } from \"../models/categories.model\";\r\n\r\nexport async function WordSearchCategories(): Promise<IWordSearchCategories> {\r\n   return (await fetch(`${process.env.PUBLIC_URL}/words/_categories.json`))\r\n      .json();\r\n}","import { createSlice } from '@reduxjs/toolkit'\r\nimport { IState } from '../store';\r\n\r\nexport const categoriesSlice = createSlice({\r\n   name: 'categories',\r\n   initialState: {\r\n      values: []\r\n   },\r\n   reducers: {\r\n      setCategories: (state, action) => {\r\n         state.values = action.payload;\r\n      }\r\n   },\r\n})\r\n\r\nexport const { setCategories } = categoriesSlice.actions\r\n\r\nexport const selectCategories = (state: IState) => state.categories.values;\r\n\r\nexport default categoriesSlice.reducer","import { useEffect } from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { Link, useNavigate } from \"react-router-dom\";\r\nimport { WordSearchCategories } from \"../helpers/categories\";\r\nimport { selectCategories, setCategories } from \"../store/reducers/categories.reducer\";\r\n\r\nexport function ChooseCategory() {\r\n   const navigate = useNavigate();\r\n   const dispatch = useDispatch()\r\n\r\n\r\n   const categories = useSelector(selectCategories)\r\n\r\n   useEffect(() => {\r\n      WordSearchCategories().then(res => dispatch(setCategories(res)))\r\n   }, [])\r\n\r\n   return (\r\n      <div className=\"container mt-5\">\r\n         {/*<label>בחירת גודל תפזורת:\r\n            <select className=\"form-select form-select-lg\" size={8} aria-label=\"size 3 select example\">\r\n               <option value=\"1\">23 שורות ו34 עמודות</option>\r\n               <option value=\"2\">Two</option>\r\n               <option value=\"3\">Three</option>\r\n            </select>\r\n         </label>*/}\r\n         <div className=\"row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 g-4 py-5\">\r\n            {Object.entries(categories).map(wsc =>\r\n               <Link key={wsc[1].jsonFile} to={`/generate/${wsc[0]}`}>My Profile\r\n                  <div className=\"col d-flex align-items-start\">\r\n                     <div>\r\n                        <h2 className=\"fw-bold mb-0\">{wsc[1].heb}</h2>\r\n                        <p>{wsc[1].desc}</p>\r\n                        <span role='button' className=\"btn btn-lg btn-light\">לחולל תשבץ</span>\r\n                     </div>\r\n                  </div>\r\n               </Link>\r\n            )}\r\n         </div>\r\n      </div>\r\n   );\r\n}\r\n","import { useEffect, useState } from \"react\";\r\nimport classNames from \"classnames\";\r\nimport { Button } from \"react-bootstrap\";\r\n\r\ninterface WordTableProps {\r\n   wordSearchTable: string[][];\r\n   availableSlots: string[][];\r\n}\r\nexport function WordTable(props: WordTableProps) {\r\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\r\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\r\n   const [showAnswers, setShowAnswers] = useState<boolean>(false);\r\n\r\n   useEffect(() => {\r\n      setWordSearchTable(props.wordSearchTable);\r\n   }, [props.wordSearchTable]);\r\n\r\n   useEffect(() => {\r\n      setAvailableSlots(props.availableSlots);\r\n   }, [props.availableSlots]);\r\n\r\n   return (\r\n      (wordSearchTable.length > 0 && availableSlots.length > 0) ?\r\n         <>\r\n            <div className=\"text-end my-3 d-print-none\">\r\n               <Button onClick={e => setShowAnswers(!showAnswers)} variant={showAnswers ? \"primary\" : \"outline-secondary\"}>הראה תשובות...</Button>\r\n            </div>\r\n            <table className='table table-bordered border-dark text-center fs-5'>\r\n               <tbody>\r\n                  {wordSearchTable.map((r, ri) =>\r\n                     <tr className=\"table-light\" key={ri}>{r.map((c, ci) =>\r\n                        <td className={classNames({\r\n                           \"table-primary\": availableSlots[ri][ci] === c && showAnswers\r\n                        })}\r\n                           key={ci}>{c}</td>\r\n                     )}\r\n                     </tr>\r\n                  )}\r\n               </tbody>\r\n            </table>\r\n         </> : <></>\r\n   );\r\n}\r\n","\r\nexport type LetterGrid = string[][];\r\n\r\ninterface Direction {\r\n   rowIncrement: number;\r\n   columnIncrement: number;\r\n}\r\n\r\nvar EMPTY_LETTER = \"\";\r\n\r\n// I pack words into a two-dimension letter-grid, randomizing the location and the\r\n// orientation of the characters that compose the packed words.\r\nexport class WordPacker {\r\n\r\n   private directions: Direction[];\r\n   private letterGrid: LetterGrid;\r\n   private letterGridWithoutFill: LetterGrid;\r\n   private height: number;\r\n   private skippedWords: string[];\r\n   private width: number;\r\n   private words: string[];\r\n\r\n   // I initialize the word packer with the given grid dimensions.\r\n   constructor(width: number, height: number) {\r\n\r\n      this.width = width;\r\n      this.height = height;\r\n      this.words = [];\r\n      this.skippedWords = [];\r\n\r\n      this.letterGrid = this.initializeLetterGrid();\r\n      this.letterGridWithoutFill = this.initializeLetterGrid();\r\n\r\n      // As we try to add words to the underlying letter-grid, we're going to try and\r\n      // apply them in different directions. The following collection represents the\r\n      // ROW and COLUMN increments for each direction that we are going to try.\r\n      this.directions = [\r\n         { // North.\r\n            rowIncrement: -1,\r\n            columnIncrement: 0\r\n         },\r\n         { // North-East.\r\n            rowIncrement: -1,\r\n            columnIncrement: 1\r\n         },\r\n         { // East.\r\n            rowIncrement: 0,\r\n            columnIncrement: 1\r\n         },\r\n         { // South-East.\r\n            rowIncrement: 1,\r\n            columnIncrement: 1\r\n         },\r\n         { // South.\r\n            rowIncrement: 1,\r\n            columnIncrement: 0\r\n         },\r\n         { // South-West.\r\n            rowIncrement: 1,\r\n            columnIncrement: -1\r\n         },\r\n         { // West.\r\n            rowIncrement: 0,\r\n            columnIncrement: -1\r\n         },\r\n         { // North-West.\r\n            rowIncrement: -1,\r\n            columnIncrement: -1\r\n         }\r\n      ];\r\n\r\n   }\r\n\r\n   // ---\r\n   // STATIC METHODS.\r\n   // ---\r\n\r\n   // I create a WordPacker for the given words using a grid with the given dimensions.\r\n   // Returns the populated WordPacker instance.\r\n   static createWordPacker(\r\n      words: string[],\r\n      width: number,\r\n      height: number\r\n   ): WordPacker {\r\n\r\n      const packer = new WordPacker(width, height);\r\n\r\n      // Sort the words with the longest values first. This will increase the chances\r\n      // of us being able to add more words to the grid (since smaller words can act\r\n      // more easily as \"filler words\", packing in the empty spaces).\r\n      const sortedWords = words.slice().sort((a, b) => (b.length - a.length));\r\n\r\n      for (var word of sortedWords) {\r\n         packer.addWord(word);\r\n      }\r\n      packer.letterGridWithoutFill = packer.letterGrid.map(arr => arr.slice());\r\n      // Fill in the rest of the empty spaces with random words.\r\n      packer.finalize();\r\n\r\n      return (packer);\r\n\r\n   }\r\n\r\n   // ---\r\n   // PUBLIC METHODS.\r\n   // ---\r\n\r\n   // I add the given word to the packer. Returns a boolean indicating whether or not\r\n   // the given word could be packed into the two-dimensional letter-grid.\r\n   public addWord(word: string): boolean {\r\n\r\n      var normalizedWord = word.split(' ').join('');\r\n      normalizedWord = normalizedWord.split('\\'').join('');\r\n      normalizedWord = normalizedWord.split('-').join('');\r\n      normalizedWord = normalizedWord.split(String.fromCharCode(1498)).join(String.fromCharCode(1499));\r\n      normalizedWord = normalizedWord.split(String.fromCharCode(1501)).join(String.fromCharCode(1502));\r\n      normalizedWord = normalizedWord.split(String.fromCharCode(1503)).join(String.fromCharCode(1504));\r\n      normalizedWord = normalizedWord.split(String.fromCharCode(1507)).join(String.fromCharCode(1508));\r\n      normalizedWord = normalizedWord.split(String.fromCharCode(1509)).join(String.fromCharCode(1510));\r\n\r\n\r\n      // If the given word can be wholly subsumed by one of the words that's already\r\n      // been packed into the letter-grid, it should be skipped since including it\r\n      // would lead to a confusing user experience (UX).\r\n      if (this.wordOverlapsCompletely(normalizedWord)) {\r\n         this.skippedWords.push(normalizedWord);\r\n         return (false);\r\n\r\n      }\r\n\r\n      if (this.tryToAddWord(normalizedWord)) {\r\n\r\n         this.words.push(word);\r\n         return (true);\r\n\r\n      } else {\r\n         this.skippedWords.push(word);\r\n         return (false);\r\n\r\n      }\r\n\r\n   }\r\n\r\n\r\n   // I finalize the two-dimensional letter-grid, filling-in any remaining spaces with\r\n   // random letters (A-Z).\r\n   public finalize(): void {\r\n      for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\r\n         for (let columnIndex = 0; columnIndex < this.width; columnIndex++) {\r\n            // If this grid-location is filled-in, move onto the next location.\r\n            if (this.letterGrid[rowIndex][columnIndex]) {\r\n\r\n               continue;\r\n\r\n            }\r\n\r\n            this.letterGrid[rowIndex][columnIndex] = this.randLetter();\r\n\r\n         }\r\n      }\r\n\r\n   }\r\n\r\n\r\n   // I return the two-dimensional letter-grid.\r\n   public getLetterGrid(): LetterGrid {\r\n\r\n      // In order to prevent our internal data-model from leaking out in a mutable\r\n      // fashion (ie, such that our internal structure could be mutated by an external\r\n      // context), we need to return a DEEP COPY of the letter grid.\r\n      return (this.letterGrid.map(row => row.slice()));\r\n\r\n   }\r\n\r\n   public getLetterGridClean(): LetterGrid {\r\n      return this.letterGridWithoutFill.map(row => row.slice());\r\n   }\r\n\r\n   // I return the words that could not be packed into the letter-grid.\r\n   public getSkippedWords(): string[] {\r\n      return (this.skippedWords.slice());\r\n   }\r\n\r\n   // I return the words that were packed into the letter-grid.\r\n   public getWords(): string[] {\r\n      return (this.words.slice());\r\n   }\r\n\r\n   // ---\r\n   // PRIVATE METHODS.\r\n   // ---\r\n\r\n   // I create an empty letter-grid for the current letter-packer.\r\n   private initializeLetterGrid(): LetterGrid {\r\n      const row: string[] = new Array(this.width).fill(EMPTY_LETTER);\r\n\r\n      // The empty grid will use a row-first orientation (since this is easier to\r\n      // render in the HTML markup).\r\n      return new Array(this.height).fill(EMPTY_LETTER).map(() => row.slice());\r\n\r\n   }\r\n\r\n\r\n   // I return a random letter between A-Z.\r\n   private randLetter(): string {\r\n\r\n      const letters = Array.from({ length: 27 }, (x, i) => i + 1488);\r\n      letters.splice(letters.indexOf(1498), 1);\r\n      letters.splice(letters.indexOf(1501), 1);\r\n      letters.splice(letters.indexOf(1503), 1);\r\n      letters.splice(letters.indexOf(1507), 1);\r\n      letters.splice(letters.indexOf(1509), 1);\r\n\r\n      return String.fromCharCode(letters[this.randRange(letters.length)]);\r\n   }\r\n\r\n\r\n   // I return a random value between 0 (inclusive) and the given value (exclusive).\r\n   private randRange(maxValue: number): number {\r\n      return (Math.floor(Math.random() * maxValue));\r\n\r\n   }\r\n\r\n\r\n   // I shuffle the given array of values in place.\r\n   private shuffle<T>(values: T[]): T[] {\r\n\r\n      for (var i = 0, length = values.length; i < length; i++) {\r\n         var randomIndex = this.randRange(length);\r\n\r\n         // Swap the values in the current index and the random index.\r\n         var temp = values[i];\r\n         values[i] = values[randomIndex];\r\n         values[randomIndex] = temp;\r\n\r\n      }\r\n\r\n      return (values);\r\n\r\n   }\r\n\r\n\r\n   // I try to add the given letters in the given direction at the given location on the\r\n   // letter-grid. Returns boolean indicating whether or not the letter-grid has been\r\n   // updated with the letters.\r\n   private tryToAddLettersInDirection(\r\n      letters: string[],\r\n      rowStart: number,\r\n      columnStart: number,\r\n      direction: Direction\r\n   ): boolean {\r\n\r\n      var rowIndex = rowStart;\r\n      var columnIndex = columnStart;\r\n\r\n      // Before we mutate the letter-grid, let's see if the collection of letters will\r\n      // fit on the letter-grid using the given direction.\r\n      for (let letter of letters) {\r\n\r\n         // If the current location has gone off the grid, we've run out of room for\r\n         // the letters in the given direction.\r\n         if (\r\n            (rowIndex < 0) ||\r\n            (rowIndex >= this.height) ||\r\n            (columnIndex < 0) ||\r\n            (columnIndex >= this.width)\r\n         ) {\r\n\r\n            return (false);\r\n\r\n         }\r\n\r\n         // If the current location is already populated with a non-matching letter,\r\n         // we've overlapped with an incompatible word.\r\n         if (\r\n            (this.letterGrid[rowIndex][columnIndex] !== EMPTY_LETTER) &&\r\n            (this.letterGrid[rowIndex][columnIndex] !== letter)\r\n         ) {\r\n\r\n            return (false);\r\n\r\n         }\r\n\r\n         rowIndex += direction.rowIncrement;\r\n         columnIndex += direction.columnIncrement;\r\n\r\n      }\r\n\r\n      // ASSERT: At this point, if we've made it this far, it means that all of the\r\n      // letters will fit into the letter-grid using the given direction. At this\r\n      // point, we can move ahead with applying the letters, MUTATING the letter-grid.\r\n      // Move back to the starting location and add each letter in turn.\r\n      rowIndex = rowStart;\r\n      columnIndex = columnStart;\r\n\r\n      for (let letter of letters) {\r\n\r\n         this.letterGrid[rowIndex][columnIndex] = letter;\r\n\r\n         rowIndex += direction.rowIncrement;\r\n         columnIndex += direction.columnIncrement;\r\n\r\n      }\r\n\r\n      return (true);\r\n\r\n   }\r\n\r\n\r\n   // I try to add the given word to letter-grid. Returns a boolean indicating whether\r\n   // or not the letter-grid has been updated with the given word.\r\n   private tryToAddWord(word: string): boolean {\r\n\r\n      var letters = word.split(\"\");\r\n\r\n      // To reduce the chances that every word is added in the same direction, we're\r\n      // going to randomize the order of the directions that we're going try for this\r\n      // word at the various locations on the letter-grid.\r\n      this.shuffle(this.directions);\r\n\r\n      // Randomly select the starting location on the letter-grid. From there, we will\r\n      // begin a linear scan of the grid, looking for a fitting location for the\r\n      // letters in the word.\r\n      var rowIndex = this.randRange(this.height);\r\n      var columnIndex = this.randRange(this.width);\r\n\r\n      // Performing a liner scan on a two-dimensional grid is a little tricky as we\r\n      // have to wrap the scan across rows and columns. We know that the MAX NUMBER of\r\n      // locations is equal to the TOTAL AREA of the grid.\r\n      var maxAttempts = (this.width * this.height);\r\n\r\n      for (var attempt = 0; attempt < maxAttempts; attempt++) {\r\n\r\n         // At each grid-location, we're going to try fitting the word in every\r\n         // direction, taking the first one that matches.\r\n         for (var direction of this.directions) {\r\n\r\n            if (this.tryToAddLettersInDirection(letters, rowIndex, columnIndex, direction)) {\r\n\r\n               return (true);\r\n\r\n            }\r\n\r\n         }\r\n\r\n         // If the current grid location didn't have room for the letters, we have to\r\n         // move onto the next \"linear\" location, performing a column-first scan.\r\n         // --\r\n         // CAUTION: Using PRE-INCREMENT operations here in order to increment the\r\n         // indices BEFORE consuming them in the equality-comparison.\r\n         if (++columnIndex === this.width) {\r\n\r\n            columnIndex = 0;\r\n\r\n            if (++rowIndex === this.height) {\r\n\r\n               rowIndex = 0;\r\n\r\n            }\r\n\r\n         }\r\n\r\n      }\r\n\r\n      // If we made it this far, the word could not fit into any of the scanned\r\n      // locations on the letter-grid.\r\n      return (false);\r\n\r\n   }\r\n\r\n\r\n   // I determine if the given word can be subsumed by (or can subsume) one of the words\r\n   // that's already been packed into the letter-grid (ex, \"happy\" can be wholly subsumed\r\n   // by \"unhappy\"). We can't allow for fully-overlapping words as it would be confusing\r\n   // for the consumer of the letter-grid.\r\n   private wordOverlapsCompletely(word: string): boolean {\r\n\r\n      // Get Upper-Case versions of our operands so that we don't have to worry about\r\n      // differences in case.\r\n      var normalizedWord = word.toUpperCase();\r\n      var normaliezdPackedWords = this.words.map(\r\n         (packedWord) => {\r\n\r\n            return (packedWord.toUpperCase());\r\n\r\n         }\r\n      );\r\n\r\n      for (var normalizedPackedWord of normaliezdPackedWords) {\r\n\r\n         if (\r\n            normalizedPackedWord.includes(normalizedWord) ||\r\n            normalizedWord.includes(normalizedPackedWord)\r\n         ) {\r\n\r\n            return (true);\r\n\r\n         }\r\n\r\n      }\r\n\r\n      return (false);\r\n\r\n   }\r\n\r\n}","import { useEffect, useState } from \"react\";\r\nimport { Button } from \"react-bootstrap\";\r\nimport { useParams } from \"react-router-dom\";\r\nimport { WordTable } from \"./word-table\";\r\nimport { WordPacker } from \"../helpers/word-packer\";\r\nimport { useSelector } from \"react-redux\";\r\nimport { selectCategories } from \"../store/reducers/categories.reducer\";\r\n\r\nconst randomWords = (jsonPath: string) =>\r\n   fetch(jsonPath).then(res => res.json().then((jRes: string[]) =>\r\n      jRes.sort(() => .5 - Math.random()).slice(0, 79)\r\n   ));\r\n\r\n\r\nexport function WordSearch() {\r\n   const ROWS = 18;\r\n   const COLS = 24;\r\n\r\n   const params = useParams();\r\n   const categories = useSelector(selectCategories);\r\n\r\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\r\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\r\n\r\n   const [selectedWords, setSelectedWords] = useState<string[]>([]);\r\n   const category = categories[params.category as string];\r\n\r\n   const makeTables = (words: string[]) => {\r\n      const wordPacker = WordPacker.createWordPacker(words, COLS, ROWS);\r\n\r\n      setWordSearchTable(wordPacker.getLetterGrid());\r\n      setAvailableSlots(wordPacker.getLetterGridClean());\r\n      setSelectedWords(wordPacker.getWords());\r\n   }\r\n   const fetchWordsAndMakeTables = () => randomWords(`${process.env.PUBLIC_URL}/words/${category.jsonFile}`).then(words => makeTables(words));\r\n\r\n   useEffect(() => {\r\n      fetchWordsAndMakeTables();\r\n   }, []);\r\n\r\n   return (\r\n      <>\r\n         <div className=\"container\">\r\n            <h2 className='mb-4 text-center'>תפזורת של {category.heb}</h2>\r\n            <div className='text-end'>\r\n               <Button variant=\"outline-success text-start d-print-none\" onClick={e => fetchWordsAndMakeTables()}>\r\n                  יצירת תשבץ חדש\r\n               </Button>\r\n            </div>\r\n         </div>\r\n         <div className=\"container\">\r\n            {wordSearchTable.length > 0 ?\r\n               <WordTable wordSearchTable={wordSearchTable} availableSlots={availableSlots} />\r\n               : <></>}\r\n         </div>\r\n         <div className=\"container\">\r\n            <section className='row fs-5 d-flex'>\r\n               {selectedWords.map((w, wi) => <div key={wi} tabIndex={0} className=\"col-2 flex-grow-1 \" title={w}>{w}</div>)}\r\n            </section>\r\n         </div>\r\n      </>\r\n   );\r\n}\r\n","import './App.css';\r\nimport { ChooseCategory } from \"./components/choose-category\";\r\nimport { WordSearch } from \"./components/word-search\";\r\n\r\nimport { BrowserRouter, MemoryRouter, Routes, Route } from \"react-router-dom\";\r\n\r\nfunction App() {\r\n   return (\r\n      <MemoryRouter>\r\n         <Routes>\r\n            <Route path=\"/\" element={<ChooseCategory />} />\r\n            <Route path=\"/generate/:category\" element={<WordSearch />} />\r\n         </Routes>\r\n      </MemoryRouter>\r\n   );\r\n}\r\n\r\nexport default App;\r\n\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import { configureStore } from '@reduxjs/toolkit'\r\nimport { IWordSearchCategories } from '../models/categories.model'\r\nimport categoriesReducer from './reducers/categories.reducer'\r\n\r\nexport interface IState {\r\n   categories: {\r\n      values: IWordSearchCategories;\r\n   }\r\n}\r\n\r\nexport default configureStore({\r\n   reducer: {\r\n      categories: categoriesReducer\r\n   },\r\n})","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'bootstrap/dist/css/bootstrap.rtl.min.css';\r\nimport { ThemeProvider } from \"react-bootstrap\";\r\nimport { Provider } from 'react-redux';\r\nimport store from './store/store';\r\n\r\nReactDOM.render(\r\n   <React.StrictMode>\r\n      <Provider store={store}>\r\n\r\n         <ThemeProvider dir=\"rtl\">\r\n            <App />\r\n         </ThemeProvider>\r\n      </Provider>\r\n   </React.StrictMode>,\r\n   document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}