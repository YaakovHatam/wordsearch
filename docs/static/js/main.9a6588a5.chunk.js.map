{"version":3,"sources":["helpers/categories.ts","components/choose-category.tsx","components/word-table.tsx","helpers/word-packer.ts","components/word-search.tsx","App.js","reportWebVitals.js","index.js"],"names":["WordSearchCategories","animals","jsonPath","process","heb","desc","keshet","rivers","ChooseCategory","navigate","useNavigate","wordSearchCategories","Object","entries","className","size","value","map","wsc","onClick","e","category","role","WordTable","props","useState","wordSearchTable","setWordSearchTable","availableSlots","setAvailableSlots","showAnswers","setShowAnswers","useEffect","length","Button","variant","r","ri","c","ci","classNames","WordPacker","width","height","directions","letterGrid","letterGridWithoutFill","skippedWords","words","this","initializeLetterGrid","rowIncrement","columnIncrement","word","normalizedWord","split","join","String","fromCharCode","wordOverlapsCompletely","push","tryToAddWord","rowIndex","columnIndex","randLetter","row","slice","Array","fill","letters","from","x","i","splice","indexOf","randRange","maxValue","Math","floor","random","values","randomIndex","temp","rowStart","columnStart","direction","letter","shuffle","maxAttempts","attempt","tryToAddLettersInDirection","toUpperCase","normaliezdPackedWords","packedWord","normalizedPackedWord","includes","packer","sortedWords","sort","a","b","addWord","arr","finalize","randomWords","fetch","then","res","json","jRes","WordSearch","params","useParams","selectedWords","setSelectedWords","makeTables","wordPacker","createWordPacker","getLetterGrid","getLetterGridClean","getWords","w","wi","tabIndex","title","App","basename","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","ThemeProvider","dir","document","getElementById"],"mappings":"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","file":"static/js/main.9a6588a5.chunk.js","sourcesContent":["interface IWordSearchCategories {\n   [category: string]: {\n      jsonPath: string;\n      heb: string;\n      desc: string;\n   }\n}\nexport const WordSearchCategories: IWordSearchCategories = {\n   animals: {\n      jsonPath: `${process.env.PUBLIC_URL}/words/animals.json`,\n      heb: 'חיות',\n      desc: 'תפזורת עם שמות של חיות'\n   },\n   keshet: {\n      jsonPath: `${process.env.PUBLIC_URL}/words/keshet.json`,\n      heb: 'שמות ד2',\n      desc: 'תפזורת עם שמות שמות של בנות ד2'\n   },\n   rivers: {\n      jsonPath: `${process.env.PUBLIC_URL}/words/river.json`,\n      heb: 'נחלים בישראל',\n      desc: 'שמות של נחלים בארץ ישראל'\n   }\n}","import { useNavigate } from \"react-router-dom\";\nimport { WordSearchCategories } from \"../helpers/categories\";\n\nexport function ChooseCategory() {\n   let navigate = useNavigate();\n\n   const handleClick = (category: string) => navigate(`/generate/${category}`);\n\n   const wordSearchCategories = Object.entries(WordSearchCategories);\n\n   return (\n      <div className=\"container mt-5\">\n         <label>בחירת גודל תפזורת:\n            <select className=\"form-select form-select-lg\" size={8} aria-label=\"size 3 select example\">\n               <option value=\"1\">23 שורות ו34 עמודות</option>\n               <option value=\"2\">Two</option>\n               <option value=\"3\">Three</option>\n            </select>\n         </label>\n         <div className=\"row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 g-4 py-5\">\n            {wordSearchCategories.map(wsc =>\n               <div className=\"col d-flex align-items-start\" onClick={e => handleClick(wsc[0])}>\n                  <div>\n                     <h2 className=\"fw-bold mb-0\">{wsc[1].heb}</h2>\n                     <p>{wsc[1].desc}</p>\n                     <span role='button' className=\"btn btn-lg btn-light\">לחולל תשבץ</span>\n                  </div>\n               </div>\n            )}\n         </div>\n      </div>\n   );\n}\n","import { useEffect, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { Button } from \"react-bootstrap\";\n\ninterface WordTableProps {\n   wordSearchTable: string[][];\n   availableSlots: string[][];\n}\nexport function WordTable(props: WordTableProps) {\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\n   const [showAnswers, setShowAnswers] = useState<boolean>(false);\n\n   useEffect(() => {\n      setWordSearchTable(props.wordSearchTable);\n   }, [props.wordSearchTable]);\n\n   useEffect(() => {\n      setAvailableSlots(props.availableSlots);\n   }, [props.availableSlots]);\n\n   return (\n      (wordSearchTable.length > 0 && availableSlots.length > 0) ?\n         <>\n            <div className=\"text-end my-3 d-print-none\">\n               <Button onClick={e => setShowAnswers(!showAnswers)} variant={showAnswers ? \"primary\" : \"outline-secondary\"}>הראה תשובות...</Button>\n            </div>\n            <table className='table table-bordered border-dark text-center fs-5'>\n               <tbody>\n                  {wordSearchTable.map((r, ri) =>\n                     <tr className=\"table-light\" key={ri}>{r.map((c, ci) =>\n                        <td className={classNames({\n                           \"table-primary\": availableSlots[ri][ci] === c && showAnswers\n                        })}\n                           key={ci}>{c}</td>\n                     )}\n                     </tr>\n                  )}\n               </tbody>\n            </table>\n         </> : <></>\n   );\n}\n","\nexport type LetterGrid = string[][];\n\ninterface Direction {\n   rowIncrement: number;\n   columnIncrement: number;\n}\n\nvar EMPTY_LETTER = \"\";\n\n// I pack words into a two-dimension letter-grid, randomizing the location and the\n// orientation of the characters that compose the packed words.\nexport class WordPacker {\n\n   private directions: Direction[];\n   private letterGrid: LetterGrid;\n   private letterGridWithoutFill: LetterGrid;\n   private height: number;\n   private skippedWords: string[];\n   private width: number;\n   private words: string[];\n\n   // I initialize the word packer with the given grid dimensions.\n   constructor(width: number, height: number) {\n\n      this.width = width;\n      this.height = height;\n      this.words = [];\n      this.skippedWords = [];\n\n      this.letterGrid = this.initializeLetterGrid();\n      this.letterGridWithoutFill = this.initializeLetterGrid();\n\n      // As we try to add words to the underlying letter-grid, we're going to try and\n      // apply them in different directions. The following collection represents the\n      // ROW and COLUMN increments for each direction that we are going to try.\n      this.directions = [\n         { // North.\n            rowIncrement: -1,\n            columnIncrement: 0\n         },\n         { // North-East.\n            rowIncrement: -1,\n            columnIncrement: 1\n         },\n         { // East.\n            rowIncrement: 0,\n            columnIncrement: 1\n         },\n         { // South-East.\n            rowIncrement: 1,\n            columnIncrement: 1\n         },\n         { // South.\n            rowIncrement: 1,\n            columnIncrement: 0\n         },\n         { // South-West.\n            rowIncrement: 1,\n            columnIncrement: -1\n         },\n         { // West.\n            rowIncrement: 0,\n            columnIncrement: -1\n         },\n         { // North-West.\n            rowIncrement: -1,\n            columnIncrement: -1\n         }\n      ];\n\n   }\n\n   // ---\n   // STATIC METHODS.\n   // ---\n\n   // I create a WordPacker for the given words using a grid with the given dimensions.\n   // Returns the populated WordPacker instance.\n   static createWordPacker(\n      words: string[],\n      width: number,\n      height: number\n   ): WordPacker {\n\n      const packer = new WordPacker(width, height);\n\n      // Sort the words with the longest values first. This will increase the chances\n      // of us being able to add more words to the grid (since smaller words can act\n      // more easily as \"filler words\", packing in the empty spaces).\n      const sortedWords = words.slice().sort((a, b) => (b.length - a.length));\n\n      for (var word of sortedWords) {\n         packer.addWord(word);\n      }\n      packer.letterGridWithoutFill = packer.letterGrid.map(arr => arr.slice());\n      // Fill in the rest of the empty spaces with random words.\n      packer.finalize();\n\n      return (packer);\n\n   }\n\n   // ---\n   // PUBLIC METHODS.\n   // ---\n\n   // I add the given word to the packer. Returns a boolean indicating whether or not\n   // the given word could be packed into the two-dimensional letter-grid.\n   public addWord(word: string): boolean {\n\n      var normalizedWord = word.split(' ').join('');\n      normalizedWord = normalizedWord.split(String.fromCharCode(1498)).join(String.fromCharCode(1499));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1501)).join(String.fromCharCode(1502));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1503)).join(String.fromCharCode(1504));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1507)).join(String.fromCharCode(1508));\n      normalizedWord = normalizedWord.split(String.fromCharCode(1509)).join(String.fromCharCode(1510));\n\n\n      // If the given word can be wholly subsumed by one of the words that's already\n      // been packed into the letter-grid, it should be skipped since including it\n      // would lead to a confusing user experience (UX).\n      if (this.wordOverlapsCompletely(normalizedWord)) {\n         this.skippedWords.push(normalizedWord);\n         return (false);\n\n      }\n\n      if (this.tryToAddWord(normalizedWord)) {\n\n         this.words.push(word);\n         return (true);\n\n      } else {\n         this.skippedWords.push(word);\n         return (false);\n\n      }\n\n   }\n\n\n   // I finalize the two-dimensional letter-grid, filling-in any remaining spaces with\n   // random letters (A-Z).\n   public finalize(): void {\n      for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\n         for (let columnIndex = 0; columnIndex < this.width; columnIndex++) {\n            // If this grid-location is filled-in, move onto the next location.\n            if (this.letterGrid[rowIndex][columnIndex]) {\n\n               continue;\n\n            }\n\n            this.letterGrid[rowIndex][columnIndex] = this.randLetter();\n\n         }\n      }\n\n   }\n\n\n   // I return the two-dimensional letter-grid.\n   public getLetterGrid(): LetterGrid {\n\n      // In order to prevent our internal data-model from leaking out in a mutable\n      // fashion (ie, such that our internal structure could be mutated by an external\n      // context), we need to return a DEEP COPY of the letter grid.\n      return (this.letterGrid.map(row => row.slice()));\n\n   }\n\n   public getLetterGridClean(): LetterGrid {\n      return this.letterGridWithoutFill.map(row => row.slice());\n   }\n\n   // I return the words that could not be packed into the letter-grid.\n   public getSkippedWords(): string[] {\n      return (this.skippedWords.slice());\n   }\n\n   // I return the words that were packed into the letter-grid.\n   public getWords(): string[] {\n      return (this.words.slice());\n   }\n\n   // ---\n   // PRIVATE METHODS.\n   // ---\n\n   // I create an empty letter-grid for the current letter-packer.\n   private initializeLetterGrid(): LetterGrid {\n      const row: string[] = new Array(this.width).fill(EMPTY_LETTER);\n\n      // The empty grid will use a row-first orientation (since this is easier to\n      // render in the HTML markup).\n      return new Array(this.height).fill(EMPTY_LETTER).map(() => row.slice());\n\n   }\n\n\n   // I return a random letter between A-Z.\n   private randLetter(): string {\n\n      const letters = Array.from({ length: 27 }, (x, i) => i + 1488);\n      letters.splice(letters.indexOf(1498), 1);\n      letters.splice(letters.indexOf(1501), 1);\n      letters.splice(letters.indexOf(1503), 1);\n      letters.splice(letters.indexOf(1507), 1);\n      letters.splice(letters.indexOf(1509), 1);\n\n      return String.fromCharCode(letters[this.randRange(letters.length)]);\n   }\n\n\n   // I return a random value between 0 (inclusive) and the given value (exclusive).\n   private randRange(maxValue: number): number {\n      return (Math.floor(Math.random() * maxValue));\n\n   }\n\n\n   // I shuffle the given array of values in place.\n   private shuffle<T>(values: T[]): T[] {\n\n      for (var i = 0, length = values.length; i < length; i++) {\n         var randomIndex = this.randRange(length);\n\n         // Swap the values in the current index and the random index.\n         var temp = values[i];\n         values[i] = values[randomIndex];\n         values[randomIndex] = temp;\n\n      }\n\n      return (values);\n\n   }\n\n\n   // I try to add the given letters in the given direction at the given location on the\n   // letter-grid. Returns boolean indicating whether or not the letter-grid has been\n   // updated with the letters.\n   private tryToAddLettersInDirection(\n      letters: string[],\n      rowStart: number,\n      columnStart: number,\n      direction: Direction\n   ): boolean {\n\n      var rowIndex = rowStart;\n      var columnIndex = columnStart;\n\n      // Before we mutate the letter-grid, let's see if the collection of letters will\n      // fit on the letter-grid using the given direction.\n      for (let letter of letters) {\n\n         // If the current location has gone off the grid, we've run out of room for\n         // the letters in the given direction.\n         if (\n            (rowIndex < 0) ||\n            (rowIndex >= this.height) ||\n            (columnIndex < 0) ||\n            (columnIndex >= this.width)\n         ) {\n\n            return (false);\n\n         }\n\n         // If the current location is already populated with a non-matching letter,\n         // we've overlapped with an incompatible word.\n         if (\n            (this.letterGrid[rowIndex][columnIndex] !== EMPTY_LETTER) &&\n            (this.letterGrid[rowIndex][columnIndex] !== letter)\n         ) {\n\n            return (false);\n\n         }\n\n         rowIndex += direction.rowIncrement;\n         columnIndex += direction.columnIncrement;\n\n      }\n\n      // ASSERT: At this point, if we've made it this far, it means that all of the\n      // letters will fit into the letter-grid using the given direction. At this\n      // point, we can move ahead with applying the letters, MUTATING the letter-grid.\n      // Move back to the starting location and add each letter in turn.\n      rowIndex = rowStart;\n      columnIndex = columnStart;\n\n      for (let letter of letters) {\n\n         this.letterGrid[rowIndex][columnIndex] = letter;\n\n         rowIndex += direction.rowIncrement;\n         columnIndex += direction.columnIncrement;\n\n      }\n\n      return (true);\n\n   }\n\n\n   // I try to add the given word to letter-grid. Returns a boolean indicating whether\n   // or not the letter-grid has been updated with the given word.\n   private tryToAddWord(word: string): boolean {\n\n      var letters = word.split(\"\");\n\n      // To reduce the chances that every word is added in the same direction, we're\n      // going to randomize the order of the directions that we're going try for this\n      // word at the various locations on the letter-grid.\n      this.shuffle(this.directions);\n\n      // Randomly select the starting location on the letter-grid. From there, we will\n      // begin a linear scan of the grid, looking for a fitting location for the\n      // letters in the word.\n      var rowIndex = this.randRange(this.height);\n      var columnIndex = this.randRange(this.width);\n\n      // Performing a liner scan on a two-dimensional grid is a little tricky as we\n      // have to wrap the scan across rows and columns. We know that the MAX NUMBER of\n      // locations is equal to the TOTAL AREA of the grid.\n      var maxAttempts = (this.width * this.height);\n\n      for (var attempt = 0; attempt < maxAttempts; attempt++) {\n\n         // At each grid-location, we're going to try fitting the word in every\n         // direction, taking the first one that matches.\n         for (var direction of this.directions) {\n\n            if (this.tryToAddLettersInDirection(letters, rowIndex, columnIndex, direction)) {\n\n               return (true);\n\n            }\n\n         }\n\n         // If the current grid location didn't have room for the letters, we have to\n         // move onto the next \"linear\" location, performing a column-first scan.\n         // --\n         // CAUTION: Using PRE-INCREMENT operations here in order to increment the\n         // indices BEFORE consuming them in the equality-comparison.\n         if (++columnIndex === this.width) {\n\n            columnIndex = 0;\n\n            if (++rowIndex === this.height) {\n\n               rowIndex = 0;\n\n            }\n\n         }\n\n      }\n\n      // If we made it this far, the word could not fit into any of the scanned\n      // locations on the letter-grid.\n      return (false);\n\n   }\n\n\n   // I determine if the given word can be subsumed by (or can subsume) one of the words\n   // that's already been packed into the letter-grid (ex, \"happy\" can be wholly subsumed\n   // by \"unhappy\"). We can't allow for fully-overlapping words as it would be confusing\n   // for the consumer of the letter-grid.\n   private wordOverlapsCompletely(word: string): boolean {\n\n      // Get Upper-Case versions of our operands so that we don't have to worry about\n      // differences in case.\n      var normalizedWord = word.toUpperCase();\n      var normaliezdPackedWords = this.words.map(\n         (packedWord) => {\n\n            return (packedWord.toUpperCase());\n\n         }\n      );\n\n      for (var normalizedPackedWord of normaliezdPackedWords) {\n\n         if (\n            normalizedPackedWord.includes(normalizedWord) ||\n            normalizedWord.includes(normalizedPackedWord)\n         ) {\n\n            return (true);\n\n         }\n\n      }\n\n      return (false);\n\n   }\n\n}","/* eslint-disable jsx-a11y/anchor-is-valid */\nimport { useEffect, useState } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useParams } from \"react-router-dom\";\nimport { WordSearchCategories } from \"../helpers/categories\";\nimport { WordTable } from \"./word-table\";\nimport { WordPacker } from \"../helpers/word-packer\";\n\nconst randomWords = (jsonPath: string) =>\n   fetch(jsonPath).then(res => res.json().then((jRes: string[]) =>\n      jRes.sort(() => .5 - Math.random()).slice(0, 79)\n   ));\n\n\nexport function WordSearch() {\n   const ROWS = 22;\n   const COLS = 34;\n\n   let params = useParams();\n\n   const [wordSearchTable, setWordSearchTable] = useState<string[][]>([]);\n   const [availableSlots, setAvailableSlots] = useState<string[][]>([]);\n\n   const [selectedWords, setSelectedWords] = useState<string[]>([]);\n   const category = WordSearchCategories[params.category as string];\n\n   const makeTables = (words: string[]) => {\n      const wordPacker = WordPacker.createWordPacker(words, COLS, ROWS);\n\n      setWordSearchTable(wordPacker.getLetterGrid());\n      setAvailableSlots(wordPacker.getLetterGridClean());\n      setSelectedWords(wordPacker.getWords());\n   }\n   const fetchWordsAndMakeTables = () => randomWords(category.jsonPath).then(words => makeTables(words));\n\n   useEffect(() => {\n      randomWords(category.jsonPath).then(words => makeTables(words));\n   }, [category.jsonPath]);\n\n   return (\n      <>\n         <div className=\"container\">\n            <h2 className='mb-4 text-center'>תפזורת של {category.heb}</h2>\n            <div className='text-end'>\n               <Button variant=\"outline-success text-start d-print-none\" onClick={e => fetchWordsAndMakeTables()}>\n                  יצירת תשבץ חדש\n               </Button>\n            </div>\n         </div>\n         <div className=\"container\">\n            {wordSearchTable.length > 0 ?\n               <WordTable wordSearchTable={wordSearchTable} availableSlots={availableSlots} />\n               : <></>}\n         </div>\n         <div className=\"container\">\n            <section className='row fs-5 d-flex'>\n               {selectedWords.map((w, wi) => <div key={wi} tabIndex={0} className=\"col-2 flex-grow-1 \" title={w}>{w}</div>)}\n            </section>\n         </div>\n      </>\n   );\n}\n","import './App.css';\nimport { ChooseCategory } from \"./components/choose-category\";\nimport { WordSearch } from \"./components/word-search\";\n\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\n\nfunction App() {\n   return (\n      <BrowserRouter basename=\"/wordsearch\">\n         <Routes>\n            <Route path=\"/\" element={<ChooseCategory />} />\n            <Route path=\"/generate/:category\" element={<WordSearch />} />\n         </Routes>\n      </BrowserRouter>\n   );\n}\n\nexport default App;\n\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.rtl.min.css';\nimport { ThemeProvider } from \"react-bootstrap\";\n\nReactDOM.render(\n   <React.StrictMode>\n      <ThemeProvider dir=\"rtl\">\n         <App />\n      </ThemeProvider>\n   </React.StrictMode>,\n   document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}